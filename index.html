<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>Three.js Object Tester</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100% }
    </style>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body onload="init()">
<div id="infoDiv">
    <h1>
        FUTÓS JÁTÉK
    </h1>
    <h2>
        Fuss minél messzebre anélkül, hogy akadályba ütköznél! A kezdéshez nyomj SPACE-t!
    </h2>
    <h3>
        Mozgás: jobbra-balra nyilak
    </h3>
</div>
<div id="gameOverDiv">
    <h1>
        JÁTÉK VÉGE
    </h1>
    <h2 id="endScore">
        Pontszám: 100
    </h2>
    <h2>
        Új játék kezdéséhez nyomj SPACE-t!
    </h2>
</div>
<div id="scoreDiv">
    <p id="score">
        Pontszám: 0
    </p>
</div>
<script src="js/three.js"></script>
<script src="js/tween.min.js"></script>
<script src="js/ThreeBSP.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/stats.min.js"></script>


<script>
    // Globális változók
    var WIDTH, HEIGHT, aspectRatio;
    var renderer;
    var scene, camera;
    var controls;
    let textureLoader = new THREE.TextureLoader();

    //A végtelen pályát úgy oldottam meg, hogy minden objektumból kettő létezik egyszerre,
    //melyek futószalagszerűen váltogatják egymást, folyamatos látványt eredményezve
    let groundMeshPair = [];
    let forestMeshPair = [];
    let obstacleGroupPair = [];

    let currentGroundMesh = 0;
    let heroObject;
    let stats;
    let PLANE_SIZE = 1000;
    let groundUpdateNeeded = false;
    let leftKeyPressed = false;
    let rightKeyPressed = false;
    let spacePressed = false;
    let firstGeneratedPlane = true;
    let obstacleMesh;
    let WORLD_SPEED = 0;
    let gameStarted = false;
    let gameOver = false;
    let score = 0;
    let infoHTML;
    let gameOverHTML;
    let scoreDivHTML;
    let scoreHTML;

    function init() {
        // Böngésző ablakméret lekérése és méretarány számítása
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        aspectRatio = WIDTH / HEIGHT;

        // Renderer létrehozása és DOM-hoz adása
        renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
        renderer.setSize( WIDTH, HEIGHT );
        renderer.setClearColor( 0x87cefa );
        renderer.shadowMap.enabled = true;
        document.body.appendChild( renderer.domElement );

        // Színtér létrehozása
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xa9a9a9, 0.003);

        // Talaj
        groundMeshPair[0] = createGround(0);
        groundMeshPair[1] = createGround(-1000);
        // groundMeshPair[1].material.wireframe = true;
        scene.add(groundMeshPair[0]);
        scene.add(groundMeshPair[1]);

        //Erdő
        forestMeshPair[0] = generateForest();
        forestMeshPair[1] = generateForest();
        scene.add(forestMeshPair[0]);
        forestMeshPair[1].position.z -= 1000;
        scene.add(forestMeshPair[1]);

        //Hős létrehozása, saját felszínhálóval csináltam háromszögenként
        heroObject = createHero();
        scene.add(heroObject);

        //Akadályok inicializálása és kezdeti elhelyezése
        obstacleMesh = createObstacleMesh();
        obstacleGroupPair[0] = [];
        obstacleGroupPair[1] = [];
        initializeObstacles();
        placeAndRemoveObstacles(true);

        // Fények
        var ambientLight = new THREE.AmbientLight( 0xffffff, 0.5 );
        scene.add(ambientLight);

        let dLight = new THREE.DirectionalLight( 0xdddddd, 1 );
        dLight.position.set( 0, 100, -100);
        dLight.target = heroObject;
        dLight.castShadow = true;
        dLight.shadow.mapSize.width = 2048;
        dLight.shadow.mapSize.height = 2048;
        dLight.shadow.camera.left = -50;
        dLight.shadow.camera.right = 50;
        dLight.shadow.camera.top = 50;
        dLight.shadow.camera.bottom = -50;
        scene.add(dLight);

        // Az ablak későbbi átméretezése esetén visszahívható függvény megadása
        window.addEventListener( 'resize', handleWindowResize, false );

        // Kamera létrehozása és vetítési paramétereinek beállítása
        camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
        camera.position.set(0, 18, 30);
        camera.lookAt(heroObject);

        // Kamera vezérlés
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.autoRotateSpeed = 10;

        window.addEventListener("keydown", function () {
            if (event.keyCode == 37) {
                leftKeyPressed = true;
            } else if (event.keyCode == 39) {
                rightKeyPressed = true;
            } else if (event.keyCode == 32) {
                spacePressed = true;
            }
        });

        window.addEventListener("keyup", function () {
            if (event.keyCode == 37) {
                leftKeyPressed = false;
            } else if (event.keyCode == 39) {
                rightKeyPressed = false;
            } else if (event.keyCode = 32) {
                spacePressed = false;
            }
        });

        //HTML szövegek
        infoHTML = document.getElementById("infoDiv");
        gameOverHTML = document.getElementById("gameOverDiv");
        scoreDivHTML = document.getElementById("scoreDiv");
        scoreHTML = document.getElementById("score");
        infoHTML.style.display = "block";

        addStatsObject();

        animateHero();
        // Első képkocka rajzolása
        render();
    }

    //Irányítás
    function handleControls() {
        if (!gameOver && leftKeyPressed && heroObject.position.x > -14) {
            //new TWEEN.Tween(heroObject.position.x).to(heroObject.position.x - 0.1, 10).onUpdate(() => { heroObject.position.x -= 0.1 }).start();
            heroObject.position.x -= 0.4;
        }

        if (!gameOver && rightKeyPressed && heroObject.position.x < 14) {
            heroObject.position.x += 0.4;
        }

        if (spacePressed) {
            if (!gameStarted) {
                gameStarted = true;
                infoHTML.style.display = "none";
                WORLD_SPEED = 1;
                scoreDivHTML.style.display = "block";
            } else if (gameOver) {
                location.reload();
            }
        }

    }

    //FPS bal felső sarokban
    function addStatsObject() {
        stats = new Stats();
        stats.setMode(0);

        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        document.body.appendChild( stats.domElement );
    }

    function randomIntFromInterval(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }

    //Az akadály mesh-t csak egyszer hozom létre a teljesítmény végett
    function createObstacleMesh() {
        let obstacleGeometry = new THREE.DodecahedronGeometry(6);
        let obstacleMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            shininess: 20,
            specular: 0x001011
        });
        let texture = textureLoader.load('assets/stone.jpg');
        //texture.wrapS = THREE.RepeatWrapping;
        //texture.wrapT = THREE.RepeatWrapping;
        //texture.repeat.set(5, 50);
        obstacleMaterial.map = texture;
        let obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
        obstacleMesh.position.y = 4;
        obstacleMesh.rotation.x = THREE.Math.degToRad(34);
        return obstacleMesh;
    }

    //Akadályok inicializálása
    function initializeObstacles() {
        for (let i = 0; i < 10; i++) {
            let obs = obstacleMesh.clone();
            obs.passed = false; //?
            scene.add(obs);
            obstacleGroupPair[0].push(obs);
        }
        for (let i = 0; i < 10; i++) {
            let obs = obstacleMesh.clone();
            obs.passed = false; //?
            scene.add(obs);
            obstacleGroupPair[1].push(obs);
        }
    }

    //akadályok elhelyezése, mindig a "futószalagon" következő síkra
    function placeAndRemoveObstacles(firstTime) {
        let possibleHorizontalPositions = [-12, 0, 12];
        if (firstTime) {
            for (let i = 0; i < 10; i++) {
                obstacleGroupPair[0][0].position.z = -10000;
                obstacleGroupPair[0][1].position.z = -10000;
                obstacleGroupPair[0][i].position.z = i * -100 + randomIntFromInterval(-30, 30);
                obstacleGroupPair[0][i].position.x = possibleHorizontalPositions[randomIntFromInterval(0, 2)];
                obstacleGroupPair[0][i].passed = false; //?
            }
            for (let i = 0; i < 10; i++) {
                obstacleGroupPair[1][i].position.z = (i + 10) * -100 + randomIntFromInterval(-30, 30);
                obstacleGroupPair[1][i].position.x = possibleHorizontalPositions[randomIntFromInterval(0, 2)];
                obstacleGroupPair[1][i].passed = false; //?
            }
        } else {
            for (let i = 0; i < 10; i++) {
                obstacleGroupPair[currentGroundMesh][i].position.z =  (i + 10) * -100 + randomIntFromInterval(-30, 30);
                obstacleGroupPair[currentGroundMesh][i].position.x = possibleHorizontalPositions[randomIntFromInterval(0, 2)];
                obstacleGroupPair[currentGroundMesh][i].passed = false; //?
            }
        }
    }

    //akadályok animálása
    function moveObstacles() {
        for (let i = 0; i < 10; i++) {
            obstacleGroupPair[0][i].position.z += WORLD_SPEED;
            obstacleGroupPair[1][i].position.z += WORLD_SPEED;
        }
    }

    //ütközés-ellenőrzés az akadály és a hős között
    function collisionCheck() {
        for (let i = 0; i < 10; i++) {
            let currentObstacle = obstacleGroupPair[1 - currentGroundMesh][i];
            if (!currentObstacle.passed && currentObstacle.position.z > -3 &&
                heroObject.position.x < currentObstacle.position.x + 5.4 &&
                heroObject.position.x > currentObstacle.position.x  - 5.4) {
                gameOverFunc();
            } else if (!currentObstacle.passed && currentObstacle.position.z > -3) {
                currentObstacle.passed = true;
            }
        }
    }

    //játék vége
    function gameOverFunc() {
        gameOver = true;
        WORLD_SPEED = 0;
        let lookHere = heroObject.position.clone();
        lookHere.y += 10;
        camera.lookAt(lookHere);
        controls.autoRotate = true;
        gameOverHTML.style.display = "block";
        let endScore = document.getElementById("endScore");
        endScore.innerHTML = "Pontszám: " + Math.floor(score);
        scoreDivHTML.style.display = "none";
    }

    //Fa létrehozása összetett geometriaként. Egyetlen fát használok elforgatva a teljesítmény növelése végett.
    //Sok kikommentezett kísérleti kódot tartalmaz, ezért elnézést kérek.
    function generateTree() {
        let treeObject = new THREE.Object3D();
        let trunkGeometry = new THREE.CylinderGeometry(1, 3, 25, 10);
        let trunkMesh = new THREE.Mesh(trunkGeometry, null);
        trunkMesh.position.y = 12.5;
        //trunkMesh.position.y += 16.5;
        //trunkMesh.castShadow = true;

        //let trunkBSP = new ThreeBSP(trunkMesh);

        let mainGreeneryGeometry = new THREE.SphereGeometry( 8, 32, 32 );
/*        let mainGreeneryMaterial = new THREE.MeshPhongMaterial({
            color: 0x2f7532,
            shininess: 20,
            specular: 0x001011
        });*/
        let mainGreeneryMesh = new THREE.Mesh(mainGreeneryGeometry, null);

        //mainGreeneryMesh.castShadow = true;
        //let mainGreeneryBSP = new ThreeBSP(mainGreeneryMesh);

        //let greeneryBSP = new ThreeBSP(mainGreeneryMesh);

        let greenery = new THREE.Geometry();
        mainGreeneryMesh.updateMatrix();
        greenery.merge(mainGreeneryGeometry, mainGreeneryMesh.matrix);

        let diverseGreeneryGeometry = new THREE.SphereGeometry( 8, 32, 32 );

        let diverseGreeneryMesh1 = new THREE.Mesh(diverseGreeneryGeometry, null);
        diverseGreeneryMesh1.geometry.radius = 6;
        diverseGreeneryMesh1.position.x = -3;
        diverseGreeneryMesh1.position.y = -2;
        diverseGreeneryMesh1.position.z = -3;
        diverseGreeneryMesh1.updateMatrix();
        greenery.merge(diverseGreeneryGeometry, diverseGreeneryMesh1.matrix);

        let diverseGreeneryMesh2 = diverseGreeneryMesh1.clone();
        diverseGreeneryMesh2.geometry.radius = 4;
        diverseGreeneryMesh2.position.x = 3;
        diverseGreeneryMesh2.position.y = 1;
        diverseGreeneryMesh2.position.z = 3;
        diverseGreeneryMesh2.updateMatrix();
        greenery.merge(diverseGreeneryGeometry, diverseGreeneryMesh2.matrix);

        let diverseGreeneryMesh3 = diverseGreeneryMesh1.clone();
        diverseGreeneryMesh3.geometry.radius = 5;
        diverseGreeneryMesh3.position.x = 0;
        diverseGreeneryMesh3.position.y = 3;
        diverseGreeneryMesh3.position.z = 2;
        diverseGreeneryMesh3.updateMatrix();
        greenery.merge(diverseGreeneryGeometry, diverseGreeneryMesh3.matrix);

        /*let possiblePositions = [-4, -3, -2, 2, 3, 4];
        for (let i = 0; i < 3; i++) {
            let radius = randomIntFromInterval(3, 6);
            let instance = diverseGreeneryMesh.clone();
            instance.position.x = possiblePositions[randomIntFromInterval(0, 3)];
            instance.position.z = possiblePositions[randomIntFromInterval(0, 3)];
            instance.position.y = possiblePositions[randomIntFromInterval(0, 3)];
            instance.updateMatrix();
            greenery.merge(diverseGreeneryGeometry, instance.matrix);
            //greeneryBSP = greeneryBSP.union(new ThreeBSP(instance));
        }

        let greeneryMaterial = new THREE.MeshBasicMaterial({
            color: 0x2f7532,
            shininess: 20,
            specular: 0x001011
        });*/

        let greeneryMesh = new THREE.Mesh(greenery, null);
        greeneryMesh.position.y = 28;
        treeObject.position.y = 28;
        return { trunk: trunkMesh, greenery: greeneryMesh };
    }

    //Erdő létrehozása véletlenszerűen.
    //A nagyobb teljesítmény elérése érdekében egyetlen mesh-be egyesítettem az összes farönköt és az összes lombkoronát.
    function generateForest() {
        let forest = new THREE.Object3D();
        let trunks = new THREE.Geometry();
        let greens = new THREE.Geometry();
        let tree = generateTree();
        let rowCount = 6; //8
        let rowDifference = 125; //125
        let columnCount = 4; //5
        for(let i = 0; i < 2; i++) {
            for (let j = 0; j < rowCount; j++) {
                for (let k = 0; k < columnCount; k++) {
                    let random = randomIntFromInterval(-62.5, 62.5);
                    tree.trunk.position.z = j * -1 * rowDifference + random;
                    tree.greenery.position.z = j * -1 * rowDifference + random;
                    if (i == 0) {
                        random = randomIntFromInterval(-140, -20);
                        tree.trunk.position.x = random;
                        tree.greenery.position.x = random;
                    } else {
                        random = randomIntFromInterval(20, 140);
                        tree.trunk.position.x = random;
                        tree.greenery.position.x = random;
                    }
                    tree.greenery.rotation.y = THREE.Math.degToRad(randomIntFromInterval(0, 360));
                    tree.trunk.updateMatrix();
                    tree.greenery.updateMatrix();
                    trunks.merge(tree.trunk.geometry, tree.trunk.matrix);
                    greens.merge(tree.greenery.geometry, tree.greenery.matrix);
                }
            }
        }
        let trunkMaterial = new THREE.MeshLambertMaterial({
            color: 0x8b4513,
            shininess: 20
        });
        let trunkMesh = new THREE.Mesh(trunks, trunkMaterial);

        let greeneryMaterial = new THREE.MeshLambertMaterial({
            color: 0x2f7532,
            shininess: 20
        });

        let greeneryMesh = new THREE.Mesh(greens, greeneryMaterial);

        forest.add(trunkMesh);
        forest.add(greeneryMesh);
        return forest;
    }

    //Hős létrehozása. Kézzel csináltam háromszöghálót használva.
    //Az animációt elősegítve a végtagokat csoportokba rendeztem és elmozgattam a megfelelő tengelyek körül.
    function createHero() {
        let heroObject = new THREE.Object3D();

        let lowerLeftLegHolderObject = new THREE.Object3D();
        let lowerLeftLegObject = new THREE.Object3D();
        lowerLeftLegObject.name = "lowerLeftLeg";
        let lowerRightLegHolderObject = new THREE.Object3D();
        let lowerRightLegObject = new THREE.Object3D();
        lowerRightLegObject.name = "lowerRightLeg";
        let leftLegHolderObject = new THREE.Object3D();
        let leftLegObject = new THREE.Object3D();
        leftLegObject.name = "leftLeg";
        let rightLegHolderObject = new THREE.Object3D();
        let rightLegObject = new THREE.Object3D();
        rightLegObject.name = "rightLeg";
        let lowerLeftArmHolderObject = new THREE.Object3D();
        let lowerLeftArmObject = new THREE.Object3D();
        lowerLeftArmObject.name = "lowerLeftArm";
        let lowerRightArmHolderObject = new THREE.Object3D();
        let lowerRightArmObject = new THREE.Object3D();
        lowerRightArmObject.name = "lowerRightArm";
        let leftArmHolderObject = new THREE.Object3D();
        let leftArmObject = new THREE.Object3D();
        leftArmObject.name = "leftArm";
        let rightArmHolderObject = new THREE.Object3D();
        let rightArmObject = new THREE.Object3D();
        rightArmObject.name = "rightArm";


        // LÁBFEJEK
        let footMaterial = new THREE.MeshPhongMaterial({
            color: 0x8b4513,
            shininess: 80,
            specular: 0x001011,
            side: THREE.DoubleSide
        });

        let footGeometry = new THREE.Geometry();
        footGeometry.vertices.push(
            //Talp
            new THREE.Vector3(-2, 0.1, -1), //bal elülső
            new THREE.Vector3(-2, 0.1, 2), //bal hátsó
            new THREE.Vector3(-1, 0.1, -1), //jobb elülső
            new THREE.Vector3(-1, 0.1, 2), //jobb hátsó

            new THREE.Vector3(-1.8, 1, 1), //bal közép
            new THREE.Vector3(-1.5, 0.6, 2.1), //sarok
            new THREE.Vector3(-1.2, 1, 1) //jobb közép

        //new THREE.Vector3(-3)
        );

        footGeometry.faces.push(new THREE.Face3(0, 1, 2));
        footGeometry.faces.push(new THREE.Face3(1, 3, 2));
        footGeometry.faces.push(new THREE.Face3(0, 1, 4));
        footGeometry.faces.push(new THREE.Face3(2, 6, 3));
        footGeometry.faces.push(new THREE.Face3(1, 3, 5));
        footGeometry.faces.push(new THREE.Face3(4, 1, 5));
        footGeometry.faces.push(new THREE.Face3(1, 3, 5));
        footGeometry.faces.push(new THREE.Face3(5, 3, 6));

        footGeometry.faces.push(new THREE.Face3(0, 6, 2));
        footGeometry.faces.push(new THREE.Face3(0, 4, 6));
        footGeometry.faces.push(new THREE.Face3(4, 5, 6));

        footGeometry.computeFaceNormals();

        let leftFootMesh = new THREE.Mesh(footGeometry, footMaterial);
        leftFootMesh.name = "leftFoot";
        //leftFootMesh.castShadow = true;

        let rightFootMesh = leftFootMesh.clone();
        rightFootMesh.position.x = 3;
        rightFootMesh.name = "rightFoot";
        lowerLeftLegHolderObject.add(leftFootMesh);
        lowerRightLegHolderObject.add(rightFootMesh);

        /*heroObject.add(leftFootMesh);
        heroObject.add(rightFootMesh);*/

        // LÁBSZÁRAK
        let legMaterial = new THREE.MeshPhongMaterial({
            color: 0xf3b1b4,
            shininess: 80,
            specular: 0x001011,
            side: THREE.DoubleSide
        });

        let leftLegGeometry = new THREE.Geometry();
        leftLegGeometry.vertices.push(
            new THREE.Vector3(-1.8, 1, 1), //labfej bal közép
            new THREE.Vector3(-1.5, 0.6, 2.1), //labfej sarok
            new THREE.Vector3(-1.2, 1, 1), //labfej jobb közép
            new THREE.Vector3(-1.6, 4.7, 2), //bal hatso
            new THREE.Vector3(-1.2, 4.7, 2), //jobb hatso
            new THREE.Vector3(-1.5, 4.5, 1.2), //terd alja
            new THREE.Vector3(-1.5, 4.9, 1.15), //terd teteje

        );

        leftLegGeometry.faces.push(new THREE.Face3(0, 1, 3));
        leftLegGeometry.faces.push(new THREE.Face3(1, 2, 4));
        leftLegGeometry.faces.push(new THREE.Face3(0, 2, 5));
        leftLegGeometry.faces.push(new THREE.Face3(0, 3, 5));
        leftLegGeometry.faces.push(new THREE.Face3(2, 4, 5));
        leftLegGeometry.faces.push(new THREE.Face3(1, 3, 4));
        leftLegGeometry.faces.push(new THREE.Face3(5, 6, 3));
        leftLegGeometry.faces.push(new THREE.Face3(5, 6, 4));
        leftLegGeometry.faces.push(new THREE.Face3(3, 4, 6));
        leftLegGeometry.computeFaceNormals();

        let leftLegMesh = new THREE.Mesh(leftLegGeometry, legMaterial);
        leftLegMesh.name = "leftLeg";
        //leftLegMesh.castShadow = true;



        lowerLeftLegHolderObject.add(leftLegMesh);
        lowerLeftLegHolderObject.position.y -= 4.8;
        lowerLeftLegHolderObject.position.z -= 1;
        lowerLeftLegObject.add(lowerLeftLegHolderObject);
        //lowerLeftLegObject.add(new THREE.AxisHelper(10));

        lowerLeftLegObject.position.y += 4.8;
        lowerLeftLegObject.position.z += 1;

        leftLegHolderObject.add(lowerLeftLegObject);


        let rightLegGeometry = new THREE.Geometry();
        rightLegGeometry.vertices.push(
            new THREE.Vector3(1.8, 1, 1), //labfej bal közép
            new THREE.Vector3(1.5, 0.6, 2.1), //labfej sarok
            new THREE.Vector3(1.2, 1, 1), //labfej jobb közép
            new THREE.Vector3(1.6, 4.7, 2), //bal hatso
            new THREE.Vector3(1.2, 4.7, 2), //jobb hatso
            new THREE.Vector3(1.5, 4.5, 1.2), //terd alja
            new THREE.Vector3(1.5, 4.9, 1.15), //terd teteje
        );

        rightLegGeometry.faces.push(new THREE.Face3(0, 1, 3));
        rightLegGeometry.faces.push(new THREE.Face3(1, 2, 4));
        rightLegGeometry.faces.push(new THREE.Face3(0, 5, 2));
        rightLegGeometry.faces.push(new THREE.Face3(0, 3, 5));
        rightLegGeometry.faces.push(new THREE.Face3(2, 5, 4));
        rightLegGeometry.faces.push(new THREE.Face3(1, 4, 3));
        rightLegGeometry.faces.push(new THREE.Face3(5, 6, 3));
        rightLegGeometry.faces.push(new THREE.Face3(5, 6, 4));
        rightLegGeometry.faces.push(new THREE.Face3(3, 6, 4));
        rightLegGeometry.computeFaceNormals();

        let rightLegMesh = new THREE.Mesh(rightLegGeometry, legMaterial);
        rightLegMesh.name = "rightLeg";
        //rightLegMesh.castShadow = true;

        lowerRightLegHolderObject.add(rightLegMesh);
        lowerRightLegHolderObject.position.y -= 4.8;
        lowerRightLegHolderObject.position.z -= 1;

        lowerRightLegObject.add(lowerRightLegHolderObject);
        lowerRightLegObject.position.y += 4.8;
        lowerRightLegObject.position.z += 1;

        rightLegHolderObject.add(lowerRightLegObject);


        //COMBOK
        let thighMaterial = new THREE.MeshPhongMaterial({
            color: 0x0000ff,
            shininess: 80,
            specular: 0x001011,
            side: THREE.DoubleSide
        });

        let leftThighGeometry = new THREE.Geometry();
        leftThighGeometry.vertices.push(
            new THREE.Vector3(-1.6, 4.7, 2), //labszar bal hatso
            new THREE.Vector3(-1.2, 4.7, 2), //labszar jobb hatso
            new THREE.Vector3(-1.5, 4.9, 1.15), //terd teteje

            new THREE.Vector3(-0.5, 8, 1.5), //comb jobb kozep teteje
            new THREE.Vector3(-1.5, 8.5, 2), //comb hatso kozep
            new THREE.Vector3(-1.5, 8.6, 1.5), //comb bal kozep teteje
            new THREE.Vector3(-1.2, 8.5, 0.9), //comb elulso teteje

        );

        leftThighGeometry.faces.push(new THREE.Face3(1, 2, 3));
        leftThighGeometry.faces.push(new THREE.Face3(0, 1, 4));
        leftThighGeometry.faces.push(new THREE.Face3(1, 3, 4));
        leftThighGeometry.faces.push(new THREE.Face3(0, 2, 5));
        leftThighGeometry.faces.push(new THREE.Face3(0, 4, 5));
        leftThighGeometry.faces.push(new THREE.Face3(2, 5, 6));
        leftThighGeometry.faces.push(new THREE.Face3(2, 3, 6));

        leftThighGeometry.computeFaceNormals();

        let leftThighMesh = new THREE.Mesh(leftThighGeometry, thighMaterial);
        leftThighMesh.name = "leftThigh";
        //leftThighMesh.castShadow = true;

        leftLegHolderObject.add(leftThighMesh);
        leftLegHolderObject.position.y -= 8.5;
        leftLegHolderObject.position.z -= 1.3;

        leftLegObject.add(leftLegHolderObject);
        // leftLegObject.add(new THREE.AxisHelper(10));
        leftLegObject.position.y += 8.5;
        leftLegObject.position.z += 1.3;

        //heroObject.add(leftThighMesh);

        let rightThighGeometry = new THREE.Geometry();
        rightThighGeometry.vertices.push(
            new THREE.Vector3(1.6, 4.7, 2), //labszar bal hatso
            new THREE.Vector3(1.2, 4.7, 2), //labszar jobb hatso
            new THREE.Vector3(1.5, 4.9, 1.15), //terd teteje

            new THREE.Vector3(0.5, 8, 1.5), //comb jobb kozep teteje
            new THREE.Vector3(1.5, 8.5, 2), //comb hatso kozep
            new THREE.Vector3(1.5, 8.6, 1.5), //comb bal kozep teteje
            new THREE.Vector3(1.2, 8.5, 0.9), //comb elulso teteje

        );

        rightThighGeometry.faces.push(new THREE.Face3(1, 2, 3));
        rightThighGeometry.faces.push(new THREE.Face3(0, 1, 4));
        rightThighGeometry.faces.push(new THREE.Face3(1, 3, 4));
        rightThighGeometry.faces.push(new THREE.Face3(0, 2, 5));
        rightThighGeometry.faces.push(new THREE.Face3(0, 4, 5));
        rightThighGeometry.faces.push(new THREE.Face3(2, 6, 5));
        rightThighGeometry.faces.push(new THREE.Face3(2, 6, 3));


        rightThighGeometry.computeFaceNormals();

        let rightThighMesh = new THREE.Mesh(rightThighGeometry, thighMaterial);

        //rightThighMesh.castShadow = true;
        rightThighMesh.name = "rightLeg";

        rightLegHolderObject.add(rightThighMesh);
        rightLegHolderObject.position.y -= 8.5;
        rightLegHolderObject.position.z -= 1.3;

        rightLegObject.add(rightLegHolderObject);
        // rightLegObject.add(new THREE.AxisHelper(10));
        rightLegObject.position.y += 8.5;
        rightLegObject.position.z += 1.3;


        // TÖRZS
        let torsoMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ffff,
            vertexColors: THREE.FaceColors,
            shininess: 80,
            specular: 0xadd8e6,
            side: THREE.DoubleSide
        });

        let torsoGeometry = new THREE.Geometry();
        torsoGeometry.vertices.push(
            new THREE.Vector3(-0.5, 8, 1.5), //bal comb jobb kozep teteje
            new THREE.Vector3(-1.5, 8.5, 2), //bal comb hatso kozep
            new THREE.Vector3(-1.5, 8.6, 1.5), //bal comb bal kozep teteje
            new THREE.Vector3(-1.2, 8.5, 0.9), //bal comb elulso teteje

            new THREE.Vector3(0.5, 8, 1.5), //jobb comb bal kozep teteje
            new THREE.Vector3(1.5, 8.5, 2), //jobb comb hatso kozep
            new THREE.Vector3(1.5, 8.6, 1.5), //jobb comb jobb kozep teteje
            new THREE.Vector3(1.2, 8.5, 0.9), //jobb comb elulso teteje

            new THREE.Vector3(0, 7.9, 1.5), //combok kozott kozep 8
            new THREE.Vector3(0, 8.5, 2.3), //fenek kozep lent 9
            new THREE.Vector3(-1.5, 9.6, 2), //fenek bal hatso fent 10
            new THREE.Vector3(1.5, 9.6, 2), //fenek jobb hatso fent 11
            new THREE.Vector3(0, 9.5, 2.3), //fenek kozep fent 12
            new THREE.Vector3(0, 8.4, 0.8), //elol lent 13
            new THREE.Vector3(0, 10.8, 1.9), //derek hatul kozep 14
            new THREE.Vector3(-1.3, 10.8, 1.7), //derek bal hatso fent 15
            new THREE.Vector3(1.3, 10.8, 1.7), //derek jobb hatso fent 16
            new THREE.Vector3(-1.4, 10.7, 1.2), //derek bal elol fent 17
            new THREE.Vector3(1.4, 10.7, 1), //derek jobb elol fent 18
            new THREE.Vector3(0, 10.65, 0.8), //derek elol kozep 19

            new THREE.Vector3(0, 13, 2.4), //hat kozep kozep 20
            new THREE.Vector3(-1.3, 13, 2), //hat bal kozep 21
            new THREE.Vector3(1.3, 13, 2), //hat jobb kozep 22

            new THREE.Vector3(-1.4, 13, 1), //mell bal 23
            new THREE.Vector3(1.4, 13, 1), //mell jobb 24
            new THREE.Vector3(0, 13, 0.9), //mell kozep 25
            new THREE.Vector3(-1.4, 13.5, 2), //kezto bal hatso 26
            new THREE.Vector3(-1.5, 13.5, 1), //kezto bal elulso 27
            new THREE.Vector3(1.4, 13.6, 2), //kezto jobb hatso 28
            new THREE.Vector3(1.5, 13.6, 1), //kezto jobb  elulso 29

            new THREE.Vector3(0, 14, 2), // nyakto hatul 30
            new THREE.Vector3(-0.4, 14, 1.5), //nyakto bal 31
            new THREE.Vector3(0.4, 14, 1.5), //nyakto jobb 32
            new THREE.Vector3(0, 14, 1), //nyakto elol 33
        );

        torsoGeometry.faces.push(new THREE.Face3(0, 8, 9));
        torsoGeometry.faces.push(new THREE.Face3(4, 8, 9));
        torsoGeometry.faces.push(new THREE.Face3(1, 0, 9));
        torsoGeometry.faces.push(new THREE.Face3(5, 4, 9));
        torsoGeometry.faces.push(new THREE.Face3(1, 2, 10));
        torsoGeometry.faces.push(new THREE.Face3(5, 6, 11));
        torsoGeometry.faces.push(new THREE.Face3(1, 9, 12));
        torsoGeometry.faces.push(new THREE.Face3(1, 10, 12));
        torsoGeometry.faces.push(new THREE.Face3(5, 11, 12));
        torsoGeometry.faces.push(new THREE.Face3(5, 9, 12));
        torsoGeometry.faces.push(new THREE.Face3(0, 3, 13));
        torsoGeometry.faces.push(new THREE.Face3(4, 7, 13));
        torsoGeometry.faces.push(new THREE.Face3(0, 8, 13));
        torsoGeometry.faces.push(new THREE.Face3(4, 8, 13));
        torsoGeometry.faces.push(new THREE.Face3(10, 12, 14));
        torsoGeometry.faces.push(new THREE.Face3(11, 14, 12));
        torsoGeometry.faces.push(new THREE.Face3(10, 14, 15));
        torsoGeometry.faces.push(new THREE.Face3(11, 16, 14));

        torsoGeometry.faces.push(new THREE.Face3(2, 3, 17));
        torsoGeometry.faces.push(new THREE.Face3(6, 18, 7));
        torsoGeometry.faces.push(new THREE.Face3(2, 10, 17));
        torsoGeometry.faces.push(new THREE.Face3(10, 15, 17));
        torsoGeometry.faces.push(new THREE.Face3(6, 18, 11));
        torsoGeometry.faces.push(new THREE.Face3(11, 16, 18));

        torsoGeometry.faces.push(new THREE.Face3(3, 13, 19));
        torsoGeometry.faces.push(new THREE.Face3(7, 13, 19));
        torsoGeometry.faces.push(new THREE.Face3(3, 19, 17));
        torsoGeometry.faces.push(new THREE.Face3(7, 19, 18));

        torsoGeometry.faces.push(new THREE.Face3(14, 15, 20));
        torsoGeometry.faces.push(new THREE.Face3(14, 16, 20));
        torsoGeometry.faces.push(new THREE.Face3(15, 20, 21));
        torsoGeometry.faces.push(new THREE.Face3(16, 20, 22));

        torsoGeometry.faces.push(new THREE.Face3(15, 17, 23));
        torsoGeometry.faces.push(new THREE.Face3(15, 21, 23));
        torsoGeometry.faces.push(new THREE.Face3(16, 24, 18));
        torsoGeometry.faces.push(new THREE.Face3(16, 22, 24));
        torsoGeometry.faces.push(new THREE.Face3(17, 23, 25));
        torsoGeometry.faces.push(new THREE.Face3(17, 19, 25));
        torsoGeometry.faces.push(new THREE.Face3(18, 24, 25));
        torsoGeometry.faces.push(new THREE.Face3(18, 19, 25));

        torsoGeometry.faces.push(new THREE.Face3(21, 23, 26));
        torsoGeometry.faces.push(new THREE.Face3(23, 26, 27));
        torsoGeometry.faces.push(new THREE.Face3(22, 24, 28));
        torsoGeometry.faces.push(new THREE.Face3(24, 28, 29));

        torsoGeometry.faces.push(new THREE.Face3(20, 26, 30));
        torsoGeometry.faces.push(new THREE.Face3(20, 21, 26));
        torsoGeometry.faces.push(new THREE.Face3(20, 28, 30));
        torsoGeometry.faces.push(new THREE.Face3(20, 22, 28));

        torsoGeometry.faces.push(new THREE.Face3(26, 30, 31));
        torsoGeometry.faces.push(new THREE.Face3(26, 27, 31));
        torsoGeometry.faces.push(new THREE.Face3(23, 25, 33));
        torsoGeometry.faces.push(new THREE.Face3(23, 27, 33));
        torsoGeometry.faces.push(new THREE.Face3(27, 31, 33));

        torsoGeometry.faces.push(new THREE.Face3(28, 30, 32));
        torsoGeometry.faces.push(new THREE.Face3(28, 29, 32));
        torsoGeometry.faces.push(new THREE.Face3(24, 25, 33));
        torsoGeometry.faces.push(new THREE.Face3(24, 29, 33));
        torsoGeometry.faces.push(new THREE.Face3(29, 32, 33));

        torsoGeometry.computeFaceNormals();


        for (let i = 0; i < 14; i++) {
            torsoGeometry.faces[i].color.setHex(0x0000ff);
        }

        let torsoMesh = new THREE.Mesh(torsoGeometry, torsoMaterial);

        //torsoMesh.castShadow = true;
        torsoMesh.name = "torso";

        //FEJ
        let headMaterial = new THREE.MeshPhongMaterial({
            color: 0xf3b1b4,
            vertexColors: THREE.FaceColors,
            shininess: 80,
            specular: 0x001011,
            side: THREE.DoubleSide
        });

        let headGeometry = new THREE.Geometry();
        headGeometry.vertices.push(
            //Nyak
            new THREE.Vector3(0, 14, 2), // nyakto hatul 0
            new THREE.Vector3(-0.4, 14, 1.5), //nyakto bal 1
            new THREE.Vector3(0.4, 14, 1.5), //nyakto jobb 2
            new THREE.Vector3(0, 14, 1), //nyakto elol 3
            new THREE.Vector3(0, 14.3, 2), //nyak teteje hatul 4 *****
            new THREE.Vector3(-0.4, 14.3, 1.5), //nyak teteje bal 5 *****
            new THREE.Vector3(0.4, 14.3, 1.5), //nyak teteje jobb 6 *****
            new THREE.Vector3(0, 14.3, 1), //nyak teteje elol 7

            //Fej
            new THREE.Vector3(-0.2, 14.55, 0.7), //all bal 8
            new THREE.Vector3(0.2, 14.55, 0.7), //all jobb 9
            new THREE.Vector3(-0.2, 14.8, 0.7), //arc bal 10
            new THREE.Vector3(0.2, 14.8, 0.7), //arc jobb 11
            new THREE.Vector3(0, 14.8, 0.5), //orrcimpa 12
            new THREE.Vector3(0, 15.3, 0.7), //orr teteje 13

            new THREE.Vector3(-0.5, 14.8, 1.5), //fej lent bal 14 *****
            new THREE.Vector3(0.5, 14.8, 1.5), //fej lent jobb 15 *****

            new THREE.Vector3(-0.2, 15.4, 0.7), //homlok bal 16
            new THREE.Vector3(0.2, 15.4, 0.7), //homlok jobb 17

            new THREE.Vector3(0, 14.8, 2.2), //fej lent hatul 18 ******

            new THREE.Vector3(-0.5, 15.4, 1.5), //fej fent bal 19
            new THREE.Vector3(0.5, 15.4, 1.5), //fej fent jobb 20
            new THREE.Vector3(0, 15.4, 2.2), //fej fent hatul 21

            new THREE.Vector3(-0.2, 15.6, 1.8), //fejteto bal hatul 22
            new THREE.Vector3(0.2, 15.6, 1.8), //fejteto jobb hatul 23
            new THREE.Vector3(0, 15.6, 0.5), //fejteto  elol 24




        );

        headGeometry.faces.push(new THREE.Face3(0, 1, 2));
        headGeometry.faces.push(new THREE.Face3(1, 2, 3));
        headGeometry.faces.push(new THREE.Face3(0, 1, 5));
        headGeometry.faces.push(new THREE.Face3(0, 4, 5));
        headGeometry.faces.push(new THREE.Face3(0, 2, 6));
        headGeometry.faces.push(new THREE.Face3(4, 6, 0));
        headGeometry.faces.push(new THREE.Face3(1, 3, 7));
        headGeometry.faces.push(new THREE.Face3(7, 5, 1));
        headGeometry.faces.push(new THREE.Face3(6, 7, 2));
        headGeometry.faces.push(new THREE.Face3(2, 3, 7));

        headGeometry.faces.push(new THREE.Face3(5, 7, 8));
        headGeometry.faces.push(new THREE.Face3(6, 7, 9));
        headGeometry.faces.push(new THREE.Face3(7, 8, 9));
        headGeometry.faces.push(new THREE.Face3(2, 3, 7));
        headGeometry.faces.push(new THREE.Face3(8, 9, 10));
        headGeometry.faces.push(new THREE.Face3(10, 11, 9));
        headGeometry.faces.push(new THREE.Face3(10, 11, 12));
        headGeometry.faces.push(new THREE.Face3(10, 12, 13));
        headGeometry.faces.push(new THREE.Face3(11, 12, 13));

        headGeometry.faces.push(new THREE.Face3(5, 14, 10));
        headGeometry.faces.push(new THREE.Face3(5, 8, 10)); // 20 20 20 20 20 20
        headGeometry.faces.push(new THREE.Face3(6, 15, 11));
        headGeometry.faces.push(new THREE.Face3(6, 9, 11));

        headGeometry.faces.push(new THREE.Face3(10, 11, 16));
        headGeometry.faces.push(new THREE.Face3(11, 16, 17));

        headGeometry.faces.push(new THREE.Face3(16, 14, 10)); // 11 15 17
        headGeometry.faces.push(new THREE.Face3(11, 15, 17));
        headGeometry.faces.push(new THREE.Face3(4, 18, 6));
        headGeometry.faces.push(new THREE.Face3(18, 15, 6));


        headGeometry.faces.push(new THREE.Face3(4, 5, 18));
        headGeometry.faces.push(new THREE.Face3(18, 14, 5)); // 30 30 30 30 30
        headGeometry.faces.push(new THREE.Face3(16, 19, 14));
        headGeometry.faces.push(new THREE.Face3(14, 19, 18));
        headGeometry.faces.push(new THREE.Face3(21, 19, 18));
        headGeometry.faces.push(new THREE.Face3(18, 21, 15));
        headGeometry.faces.push(new THREE.Face3(21, 20, 15));
        headGeometry.faces.push(new THREE.Face3(17, 20, 15));

        headGeometry.faces.push(new THREE.Face3(22, 23, 21));
        headGeometry.faces.push(new THREE.Face3(19, 21, 22));

        headGeometry.faces.push(new THREE.Face3(22, 19, 16));
        headGeometry.faces.push(new THREE.Face3(22, 24, 16));

        headGeometry.faces.push(new THREE.Face3(16, 17, 24));

        headGeometry.faces.push(new THREE.Face3(21, 23, 20));
        headGeometry.faces.push(new THREE.Face3(23, 20, 17));
        headGeometry.faces.push(new THREE.Face3(17, 23, 24));


        headGeometry.faces.push(new THREE.Face3(22, 23, 24));

        headGeometry.computeFaceNormals();
        for (let i = 27; i < 46; i++) {
            headGeometry.faces[i].color.setHex(0x8b4513);
        }
        let headMesh = new THREE.Mesh(headGeometry, headMaterial);
        headMesh.name = "head";
        //headMesh.castShadow = true;

        // BAL KAR ALSÓ RÉSZE
        let lowerLeftArmMaterial = new THREE.MeshPhongMaterial({
            color: 0xf3b1b4,
            shininess: 80,
            specular: 0x001011,
            side: THREE.DoubleSide
        });

        let lowerLeftArmGeometry = new THREE.Geometry();
        lowerLeftArmGeometry.vertices.push(
            new THREE.Vector3(-2.0, 11.5, 1.7), // konyok lent hatso 9
            new THREE.Vector3(-2.0, 11.5, 1.3), // konyok lent elol 10
            new THREE.Vector3(-2.4, 11.5, 1.7), // konyok fent hatso 11
            new THREE.Vector3(-2.4, 11.5, 1.3), // konyok fent elol 12
            new THREE.Vector3(-2.3, 10, 1.4), // csuklo kint elol 13
            new THREE.Vector3(-2.3, 10, 1.6), // csuklo kint hatul 14
            new THREE.Vector3(-2.1, 10, 1.4), // csuklo bent elol 15
            new THREE.Vector3(-2.1, 10, 1.6), // csuklo bent hatul 16

            new THREE.Vector3(-2.3, 10, 1.3), // kez kint elol 17
            new THREE.Vector3(-2.3, 10, 1.7), // kez kint hatul 18
            new THREE.Vector3(-2.1, 10, 1.3), // kez  bent elol 19
            new THREE.Vector3(-2.1, 10, 1.7), // kez bent hatul 20
            new THREE.Vector3(-2.3, 9.3, 1.3), // kez kint lent elol 21
            new THREE.Vector3(-2.3, 9.3, 1.7), // kez kint lent hatul 22
            new THREE.Vector3(-2.1, 9.3, 1.3), // kez bent lent elol 23
            new THREE.Vector3(-2.1, 9.3, 1.7), // kez bent lent hatul 24


        );


        lowerLeftArmGeometry.faces.push(new THREE.Face3(0, 1, 2));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(2, 3, 1));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(2, 3, 4));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(4, 5, 2));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(6, 7, 0));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(1, 0, 6));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(5, 7, 0));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(0, 2, 5));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(1, 3, 4));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(4, 6, 1));

        lowerLeftArmGeometry.faces.push(new THREE.Face3(8, 9, 10));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(10, 11, 9));

        lowerLeftArmGeometry.faces.push(new THREE.Face3(8, 9, 12));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(12, 13, 9));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(8, 10, 12));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(12, 14, 10));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(10, 11, 14));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(14, 15, 11));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(9, 11, 15));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(15, 13, 9));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(12, 13, 14));
        lowerLeftArmGeometry.faces.push(new THREE.Face3(14, 15, 13));


        lowerLeftArmGeometry.computeFaceNormals();

        let lowerLeftArmMesh = new THREE.Mesh(lowerLeftArmGeometry, lowerLeftArmMaterial);
        lowerLeftArmMesh.name = "lowerLeftArm";
        //lowerLeftArmMesh.castShadow = true;

        lowerLeftArmHolderObject.add(lowerLeftArmMesh);
        lowerLeftArmHolderObject.position.y -= 11.5;
        lowerLeftArmHolderObject.position.z -= 1.5;

        lowerLeftArmObject.add(lowerLeftArmHolderObject);
        //lowerLeftArmObject.add(new THREE.AxisHelper(10));
        lowerLeftArmObject.position.y += 11.5;
        lowerLeftArmObject.position.z += 1.5;

        leftArmHolderObject.add(lowerLeftArmObject);

        // JOBB KAR ALSÓ RÉSZE
        let lowerRightArmMaterial = new THREE.MeshPhongMaterial({
            color: 0xf3b1b4,
            shininess: 80,
            specular: 0x001011,
            side: THREE.DoubleSide
        });

        let lowerRightArmGeometry = new THREE.Geometry();
        lowerRightArmGeometry.vertices.push(
            new THREE.Vector3(2.0, 11.5, 1.7), // konyok lent hatso 9
            new THREE.Vector3(2.0, 11.5, 1.3), // konyok lent elol 10
            new THREE.Vector3(2.4, 11.5, 1.7), // konyok fent hatso 11
            new THREE.Vector3(2.4, 11.5, 1.3), // konyok fent elol 12
            new THREE.Vector3(2.3, 10, 1.4), // csuklo kint elol 13
            new THREE.Vector3(2.3, 10, 1.6), // csuklo kint hatul 14
            new THREE.Vector3(2.1, 10, 1.4), // csuklo bent elol 15
            new THREE.Vector3(2.1, 10, 1.6), // csuklo bent hatul 16

            new THREE.Vector3(2.3, 10, 1.3), // kez kint elol 17
            new THREE.Vector3(2.3, 10, 1.7), // kez kint hatul 18
            new THREE.Vector3(2.1, 10, 1.3), // kez  bent elol 19
            new THREE.Vector3(2.1, 10, 1.7), // kez bent hatul 20
            new THREE.Vector3(2.3, 9.3, 1.3), // kez kint lent elol 21
            new THREE.Vector3(2.3, 9.3, 1.7), // kez kint lent hatul 22
            new THREE.Vector3(2.1, 9.3, 1.3), // kez bent lent elol 23
            new THREE.Vector3(2.1, 9.3, 1.7), // kez bent lent hatul 24


        );


        lowerRightArmGeometry.faces.push(new THREE.Face3(0, 1, 2));
        lowerRightArmGeometry.faces.push(new THREE.Face3(2, 3, 1));
        lowerRightArmGeometry.faces.push(new THREE.Face3(2, 3, 4));
        lowerRightArmGeometry.faces.push(new THREE.Face3(4, 5, 2));
        lowerRightArmGeometry.faces.push(new THREE.Face3(6, 7, 0));
        lowerRightArmGeometry.faces.push(new THREE.Face3(1, 0, 6));
        lowerRightArmGeometry.faces.push(new THREE.Face3(5, 7, 0));
        lowerRightArmGeometry.faces.push(new THREE.Face3(0, 2, 5));
        lowerRightArmGeometry.faces.push(new THREE.Face3(1, 3, 4));
        lowerRightArmGeometry.faces.push(new THREE.Face3(4, 6, 1));

        lowerRightArmGeometry.faces.push(new THREE.Face3(8, 9, 10));
        lowerRightArmGeometry.faces.push(new THREE.Face3(10, 11, 9));

        lowerRightArmGeometry.faces.push(new THREE.Face3(8, 9, 12));
        lowerRightArmGeometry.faces.push(new THREE.Face3(12, 13, 9));
        lowerRightArmGeometry.faces.push(new THREE.Face3(8, 10, 12));
        lowerRightArmGeometry.faces.push(new THREE.Face3(12, 14, 10));
        lowerRightArmGeometry.faces.push(new THREE.Face3(10, 11, 14));
        lowerRightArmGeometry.faces.push(new THREE.Face3(14, 15, 11));
        lowerRightArmGeometry.faces.push(new THREE.Face3(9, 11, 15));
        lowerRightArmGeometry.faces.push(new THREE.Face3(15, 13, 9));
        lowerRightArmGeometry.faces.push(new THREE.Face3(12, 13, 14));
        lowerRightArmGeometry.faces.push(new THREE.Face3(14, 15, 13));


        lowerRightArmGeometry.computeFaceNormals();

        let lowerRightArmMesh = new THREE.Mesh(lowerRightArmGeometry, lowerRightArmMaterial);
        lowerRightArmMesh.name = "lowerRightArm";
        //lowerRightArmMesh.castShadow = true;

        lowerRightArmHolderObject.add(lowerRightArmMesh);
        lowerRightArmHolderObject.position.y -= 11.5;
        lowerRightArmHolderObject.position.z -= 1.5;

        lowerRightArmObject.add(lowerRightArmHolderObject);
        //lowerRightArmObject.add(new THREE.AxisHelper(10));
        lowerRightArmObject.position.y += 11.5;
        lowerRightArmObject.position.z += 1.5;

        rightArmHolderObject.add(lowerRightArmObject);


        // BAL KAR FELSŐ RÉSZE
        let upperLeftArmMaterial = new THREE.MeshPhongMaterial({
            color: 0xf3b1b4,
            shininess: 80,
            specular: 0x001011,
            side: THREE.DoubleSide
        });

        let upperLeftArmGeometry = new THREE.Geometry();
        upperLeftArmGeometry.vertices.push(
            new THREE.Vector3(-1.4, 13, 1), //mell bal 0
            new THREE.Vector3(-1.4, 13.5, 2), //kezto bal hatso 1
            new THREE.Vector3(-1.5, 13.5, 1), //kezto bal elulso 2
            new THREE.Vector3(-1.3, 13, 2), //hat bal kozep 3
            new THREE.Vector3(-2.0, 11.5, 1.7), // konyok lent hatso 8
            new THREE.Vector3(-2.0, 11.5, 1.3), // konyok lent elol 9
            new THREE.Vector3(-2.4, 11.5, 1.7), // konyok fent hatso 10
            new THREE.Vector3(-2.4, 11.5, 1.3), // konyok fent elol 11
        );

        upperLeftArmGeometry.faces.push(new THREE.Face3(0, 1, 2));
        upperLeftArmGeometry.faces.push(new THREE.Face3(2, 3, 0));
        upperLeftArmGeometry.faces.push(new THREE.Face3(0, 3, 4));
        upperLeftArmGeometry.faces.push(new THREE.Face3(0, 5, 4));
        upperLeftArmGeometry.faces.push(new THREE.Face3(1, 2, 6));
        upperLeftArmGeometry.faces.push(new THREE.Face3(2, 6, 7));
        upperLeftArmGeometry.faces.push(new THREE.Face3(1, 3, 4));
        upperLeftArmGeometry.faces.push(new THREE.Face3(4, 6, 1));
        upperLeftArmGeometry.faces.push(new THREE.Face3(2, 0, 5));
        upperLeftArmGeometry.faces.push(new THREE.Face3(5, 7, 2));
        upperLeftArmGeometry.faces.push(new THREE.Face3(4, 5, 6));
        upperLeftArmGeometry.faces.push(new THREE.Face3(6, 7, 5));

        upperLeftArmGeometry.computeFaceNormals();

        let upperLeftArmMesh = new THREE.Mesh(upperLeftArmGeometry, upperLeftArmMaterial);
        upperLeftArmMesh.name = "upperLeftArm";
        //upperLeftArmMesh.castShadow = true;

        leftArmHolderObject.add(upperLeftArmMesh);
        leftArmHolderObject.position.y -= 13.2;
        leftArmHolderObject.position.z -= 1.5;
        leftArmObject.add(leftArmHolderObject);
        //leftArmObject.add(new THREE.AxisHelper(10));
        leftArmObject.position.y += 13.2;
        leftArmObject.position.z += 1.5;



        // JOBB KAR FELSŐ RÉSZE
        let upperRightArmMaterial = new THREE.MeshPhongMaterial({
            color: 0xf3b1b4,
            shininess: 80,
            specular: 0x001011,
            side: THREE.DoubleSide
        });

        let upperRightArmGeometry = new THREE.Geometry();
        upperRightArmGeometry.vertices.push(
            new THREE.Vector3(1.4, 13, 1), //mell jobb 1
            new THREE.Vector3(1.4, 13.6, 2), //kezto jobb hatso 4
            new THREE.Vector3(1.5, 13.6, 1), //kezto jobb  elulso 5
            new THREE.Vector3(1.3, 13, 2), //hat jobb kozep 7
            new THREE.Vector3(2.0, 11.5, 1.7), // konyok lent hatso 8
            new THREE.Vector3(2.0, 11.5, 1.3), // konyok lent elol 9
            new THREE.Vector3(2.4, 11.5, 1.7), // konyok fent hatso 10
            new THREE.Vector3(2.4, 11.5, 1.3), // konyok fent elol 11
        );

        upperRightArmGeometry.faces.push(new THREE.Face3(0, 1, 2));
        upperRightArmGeometry.faces.push(new THREE.Face3(2, 3, 0));
        upperRightArmGeometry.faces.push(new THREE.Face3(0, 3, 4));
        upperRightArmGeometry.faces.push(new THREE.Face3(0, 5, 4));
        upperRightArmGeometry.faces.push(new THREE.Face3(1, 2, 6));
        upperRightArmGeometry.faces.push(new THREE.Face3(2, 6, 7));
        upperRightArmGeometry.faces.push(new THREE.Face3(1, 3, 4));
        upperRightArmGeometry.faces.push(new THREE.Face3(4, 6, 1));
        upperRightArmGeometry.faces.push(new THREE.Face3(2, 0, 5));
        upperRightArmGeometry.faces.push(new THREE.Face3(5, 7, 2));
        upperRightArmGeometry.faces.push(new THREE.Face3(4, 5, 6));
        upperRightArmGeometry.faces.push(new THREE.Face3(6, 7, 5));

        upperRightArmGeometry.computeFaceNormals();

        let upperRightArmMesh = new THREE.Mesh(upperRightArmGeometry, upperRightArmMaterial);
        upperRightArmMesh.name = "upperRightArm";
        //upperRightArmMesh.castShadow = true;

        rightArmHolderObject.add(upperRightArmMesh);
        rightArmHolderObject.position.y -= 13.2;
        rightArmHolderObject.position.z -= 1.5;
        rightArmObject.add(rightArmHolderObject);
        //rightArmObject.add(new THREE.AxisHelper(10));
        rightArmObject.position.y += 13.2;
        rightArmObject.position.z += 1.5;


        heroObject.add(leftLegObject);
        heroObject.add(rightLegObject);
        heroObject.add(torsoMesh);
        heroObject.add(leftArmObject);
        heroObject.add(rightArmObject);
        heroObject.add(headMesh);

        return heroObject;
    }

    //Hős animálása. Kulcs pozíciókat hoztam létre, és ezek között láncolt Tween átmeneteket használtam.
    function animateHero() {
        let keyFrames = [{
            lowerLeftLeg: -50,
            leftLeg: -40,
            lowerRightLeg: -10,
            rightLeg: 40,
            lowerLeftArm: 90,
            leftArm: 55,
            lowerRightArm: 30,
            rightArm: -55
        }, {
            lowerLeftLeg: -100,
            leftLeg: -10,
            lowerRightLeg: -35,
            rightLeg: 40,
            lowerLeftArm: 100,
            leftArm: 40,
            lowerRightArm: 30,
            rightArm: -50
        }, {
            lowerLeftLeg: -80,
            leftLeg: 40,
            lowerRightLeg: -30,
            rightLeg: 15,
            lowerLeftArm: 110,
            leftArm: -15,
            lowerRightArm: 40,
            rightArm: -15
        }, {
            lowerLeftLeg: -60,
            leftLeg: 70,
            lowerRightLeg: -10,
            rightLeg: -20,
            lowerLeftArm: 100,
            leftArm: -70,
            lowerRightArm: 70,
            rightArm: 40
        }, {
            lowerLeftLeg: -10,
            leftLeg: 40,
            lowerRightLeg: -50,
            rightLeg: -40,
            lowerLeftArm: 30,
            leftArm: -55,
            lowerRightArm: 90,
            rightArm: 55
        }, {
            lowerLeftLeg: -35,
            leftLeg: 40,
            lowerRightLeg: -100,
            rightLeg: -10,
            lowerLeftArm: 30,
            leftArm: -50,
            lowerRightArm: 100,
            rightArm: 40
        }, {
            lowerLeftLeg: -30,
            leftLeg: 15,
            lowerRightLeg: -80,
            rightLeg: 40,
            lowerLeftArm: 40,
            leftArm: -15,
            lowerRightArm: 110,
            rightArm: -15
        }, {
            lowerLeftLeg: -10,
            leftLeg: -20,
            lowerRightLeg: -60,
            rightLeg: 70,
            lowerLeftArm: 70,
            leftArm: 40,
            lowerRightArm: 100,
            rightArm: -70
        }];

        let tweens = [];

        for(let i = 0; i < 8; i++) {
            tweens.push(new TWEEN.Tween(keyFrames[i]).to(i != 7 ? keyFrames[i+1] : keyFrames[0], 150).onUpdate(function() {
                setHeroPositions(this);
            }))
        }

        for(let i = 0; i < 8; i++) {
            tweens[i].chain(tweens[i != 7 ? i+1 : 0]);
        }

        tweens[0].start();

    }


    //Segédfüggvény a hős pozíciójának beállítására
    function setHeroPositions(pos) {
        heroObject.getObjectByName("lowerLeftLeg").rotation.x = THREE.Math.degToRad(pos.lowerLeftLeg);
        heroObject.getObjectByName("leftLeg").rotation.x = THREE.Math.degToRad(pos.leftLeg);
        heroObject.getObjectByName("lowerRightLeg").rotation.x = THREE.Math.degToRad(pos.lowerRightLeg);
        heroObject.getObjectByName("rightLeg").rotation.x = THREE.Math.degToRad(pos.rightLeg);
        heroObject.getObjectByName("lowerLeftArm").rotation.x = THREE.Math.degToRad(pos.lowerLeftArm);
        heroObject.getObjectByName("leftArm").rotation.x = THREE.Math.degToRad(pos.leftArm);
        heroObject.getObjectByName("lowerRightArm").rotation.x = THREE.Math.degToRad(pos.lowerRightArm);
        heroObject.getObjectByName("rightArm").rotation.x = THREE.Math.degToRad(pos.rightArm);
    }

    //Talaj létrehozása
    function createGround(startingPos) {
        let middleGeometry = new THREE.PlaneGeometry( 40, PLANE_SIZE);
        let middleMaterial = new THREE.MeshPhongMaterial( {
            shininess: 20,
            specular: 0x111111,
            side: THREE.FrontSide,
        } );
        let texture = textureLoader.load('assets/grass.jpg');
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(1, 50);
        middleMaterial.map = texture;
        let mesh = new THREE.Mesh( middleGeometry, middleMaterial );

        mesh.receiveShadow = true;
        mesh.castShadow = false;

        for (let i = 0; i < 2; i++) {
            let sideGeometry = new THREE.PlaneGeometry( 120, PLANE_SIZE);
            let sideMaterial = new THREE.MeshPhongMaterial( {
                shininess: 20,
                specular: 0x111111,
                side: THREE.FrontSide
            } );
            texture = textureLoader.load('assets/soil.jpg');
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(5, 50);
            sideMaterial.map = texture;
            let sideMesh = new THREE.Mesh( sideGeometry, sideMaterial );
            sideMesh.receiveShadow = true;
            sideMesh.castShadow = false;
            sideMesh.position.x = i ? -80: 80;
            mesh.add(sideMesh);
        }
        mesh.rotation.x = THREE.Math.degToRad(270);
        mesh.position.z = startingPos;

        return mesh;
    }

    //Világ végtelenítése. Ha közel érünk a legenerált sík végéhez,
    // a már rég elhagyott objektumok észrevétlenül hátulról előlre kerülnek.
    function updateWorld() {
        if (groundMeshPair[currentGroundMesh].position.z >= 0 && !groundUpdateNeeded) {
            groundUpdateNeeded = true;
            currentGroundMesh = 1 - currentGroundMesh;

            scene.remove(groundMeshPair[currentGroundMesh]);
            groundMeshPair[currentGroundMesh] = createGround(-1000 + groundMeshPair[1-currentGroundMesh].position.z);
            scene.add(groundMeshPair[currentGroundMesh]);

            if (!firstGeneratedPlane) {
                scene.remove(forestMeshPair[currentGroundMesh]);
                forestMeshPair[currentGroundMesh].position.z = -1000;
                scene.add(forestMeshPair[currentGroundMesh]);

                placeAndRemoveObstacles(false);
            }

            firstGeneratedPlane = false;
            /*forestMeshPair[currentGroundMesh] = forestMeshPair[1 - currentGroundMesh];
            forestMeshPair[currentGroundMesh].position.z = 0;
            forestMeshPair[1 - currentGroundMesh] = temp;
            scene.add(forestMeshPair[currentGroundMesh]);*/

            groundUpdateNeeded = false;
            //generateForest();
            //forestObject.position.z = 0;
        }
    }

    //Pontszám kiírása
    function displayScore() {
        scoreHTML.innerHTML = "Pontszám: " + Math.floor(score);
    }

    //Ablak átméretezésének kezelése
    function handleWindowResize() {
        // Az ablak átméretezése esetén a kamera vetítési paraméterek újraszámolása
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        console.log( 'WIDTH=' + WIDTH + '; HEIGHT=' + HEIGHT );
        renderer.setSize( WIDTH, HEIGHT );
        aspectRatio = WIDTH / HEIGHT;
        camera.aspect = aspectRatio;
        camera.updateProjectionMatrix();
    }

    //Renderelés
    let render = function () {
        stats.update();
        requestAnimationFrame( render );

        // Kamera vezérlés
        controls.update();

        if (gameStarted) {
            TWEEN.update();
        }

        if (gameStarted && !gameOver) {
            score += 0.01;
        }

        groundMeshPair[0].position.z += WORLD_SPEED;
        groundMeshPair[1].position.z += WORLD_SPEED;
        forestMeshPair[0].position.z += WORLD_SPEED;
        forestMeshPair[1].position.z += WORLD_SPEED;

        displayScore();
        moveObstacles();
        collisionCheck();
        handleControls();
        updateWorld();

        renderer.render( scene, camera );
    };



</script>
</body>
</html>
